package net.xdob.ratly.jdbc.sql;

import net.xdob.ratly.fasts.serialization.FSTConfiguration;
import net.xdob.ratly.proto.jdbc.*;
import net.xdob.ratly.protocol.Message;
import net.xdob.ratly.protocol.RaftClientReply;
import org.h2.message.DbException;

import java.io.IOException;
import java.sql.*;
import java.util.ArrayList;

public class JdbcStatement implements Statement {
  private final ArrayList<String> batchCommands = new ArrayList<>();

  protected SqlClient sqlClient;
  protected ResultSet resultSet;
  protected long updateCount;
  private int fetchDirection;
  private int fetchSize;

  public JdbcStatement(SqlClient sqlClient) {
    this.sqlClient = sqlClient;
  }

  protected SQLException getSQLException(SQLExceptionProto ex) {
    return sqlClient.getSQLException(ex);
  }

  @Override
  public ResultSet executeQuery(String sql) throws SQLException {
    QueryRequestProto queryRequest = QueryRequestProto.newBuilder()
        .setSender(Sender.statement)
        .setType(QueryType.query)
        .setTx(sqlClient.getTx())
        .setDb(sqlClient.getCi().getDb())
        .setFetchDirection(fetchDirection)
        .setFetchSize(fetchSize)
        .setSql(sql)
        .build();
    return sendQuery(queryRequest);
  }

  protected SerialResultSet sendQuery(QueryRequestProto queryRequest) throws SQLException {
    QueryReplyProto queryReplyProto = sendQueryRequest(queryRequest);
    if(!queryReplyProto.hasEx()) {
      SerialResultSet rs = (SerialResultSet) getFasts().asObject(queryReplyProto.getRs().toByteArray());
      rs.resetResult();
      return rs;
    }else{
      throw getSQLException(queryReplyProto.getEx());
    }
  }

  protected QueryReplyProto sendQueryRequest(QueryRequestProto queryRequest) throws SQLException {
    try {
      RaftClientReply reply =
          sqlClient.getClient().io().sendReadOnly(Message.valueOf(queryRequest));
      return QueryReplyProto.parseFrom(reply.getMessage().getContent());
    } catch (IOException e) {
      throw new SQLException(e);
    }
  }

  protected FSTConfiguration getFasts() {
    return sqlClient.getFasts();
  }


  @Override
  public long getLargeUpdateCount() throws SQLException {
    return updateCount;
  }

  @Override
  public void setLargeMaxRows(long max) throws SQLException {
    Statement.super.setLargeMaxRows(max);
  }

  @Override
  public long getLargeMaxRows() throws SQLException {
    return Statement.super.getLargeMaxRows();
  }

  @Override
  public long[] executeLargeBatch() throws SQLException {
    UpdateRequestProto.Builder updateRequest = getUpdateRequest();
    for (int i = 0; i < batchCommands.size(); i++) {
      updateRequest.setBatchSql(i, batchCommands.get(i));
    }
    return sendUpdateBatch(updateRequest.build());
  }

  private UpdateRequestProto.Builder getUpdateRequest() {
    return UpdateRequestProto.newBuilder()
        .setSender(Sender.statement)
        .setTx(sqlClient.getTx())
        .setDb(sqlClient.getCi().getDb());
  }

  @Override
  public long executeLargeUpdate(String sql) throws SQLException {
    UpdateRequestProto.Builder updateRequest = getUpdateRequest()
        .setSql(sql);
    return sendUpdate(updateRequest.build());
  }

  @Override
  public long executeLargeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
    UpdateRequestProto.Builder updateRequest = getUpdateRequest()
        .setGeneratedKeys(autoGeneratedKeys)
        .setSql(sql);
    return sendUpdate(updateRequest.build());
  }

  @Override
  public long executeLargeUpdate(String sql, int[] columnIndexes) throws SQLException {
    UpdateRequestProto.Builder updateRequest = getUpdateRequest()
        .setSql(sql);
    array_fixed32.Builder builder = array_fixed32.newBuilder();
    for (int columnIndex : columnIndexes) {
      builder.addValue(columnIndex);
    }
    updateRequest.setColumnIndexes(builder);
    return sendUpdate(updateRequest.build());
  }

  @Override
  public long executeLargeUpdate(String sql, String[] columnNames) throws SQLException {
    UpdateRequestProto.Builder updateRequest = getUpdateRequest()
        .setSql(sql);
    array_string.Builder builder = array_string.newBuilder();
    for (String columnName : columnNames) {
      builder.addValue(columnName);
    }
    updateRequest.setColumnNames(builder);
    return sendUpdate(updateRequest.build());
  }

  @Override
  public int executeUpdate(String sql) throws SQLException {
    long updateCount = executeLargeUpdate(sql);
    return count4int(updateCount);
  }

  protected int count4int(long updateCount) {
    return updateCount <= 2147483647L ? (int) updateCount : -2;
  }

  protected long sendUpdate(UpdateRequestProto updateRequest) throws SQLException {
    checkClose();
    try {
      RaftClientReply reply =
          sqlClient.getClient().io().send(Message.valueOf(updateRequest));
      UpdateReplyProto updateReply = UpdateReplyProto.parseFrom(reply.getMessage().getContent());
      if(!updateReply.hasEx()) {
        sqlClient.addAndGetUpdateCount(1);
        return updateReply.getCount();
      }else{
        throw getSQLException(updateReply.getEx());
      }
    } catch (IOException e) {
      throw new SQLException(e);
    }
  }

  protected long[] sendUpdateBatch(UpdateRequestProto updateRequest) throws SQLException {
    checkClose();
    try {
      RaftClientReply reply =
          sqlClient.getClient().io().send(Message.valueOf(updateRequest));
      UpdateReplyProto updateReply = UpdateReplyProto.parseFrom(reply.getMessage().getContent());
      if(!updateReply.hasEx()) {
        if(updateRequest.getBatchSqlCount()>0) {
          sqlClient.addAndGetUpdateCount(updateRequest.getBatchSqlCount());
        }
        if(updateRequest.getBatchParamCount()>0) {
          sqlClient.addAndGetUpdateCount(updateRequest.getBatchParamCount());
        }
        long[] updateCounts = new long[updateReply.getCountsCount()];
        for (int i = 0; i < updateReply.getCountsList().size(); i++) {
          updateCounts[i] = updateReply.getCounts(i);
        }
        return updateCounts;
      }else{
        throw getSQLException(updateReply.getEx());
      }
    } catch (IOException e) {
      throw new SQLException(e);
    }
  }

  @Override
  public void close() throws SQLException {
    if(sqlClient!=null) {
      sqlClient.close();
      sqlClient = null;
    }
  }

  @Override
  public int getMaxFieldSize() throws SQLException {
    return 0;
  }

  @Override
  public void setMaxFieldSize(int max) throws SQLException {

  }

  @Override
  public int getMaxRows() throws SQLException {
    return 0;
  }

  @Override
  public void setMaxRows(int max) throws SQLException {

  }

  @Override
  public void setEscapeProcessing(boolean enable) throws SQLException {

  }

  @Override
  public int getQueryTimeout() throws SQLException {
    return 0;
  }

  @Override
  public void setQueryTimeout(int seconds) throws SQLException {

  }

  @Override
  public void cancel() throws SQLException {
  }

  @Override
  public SQLWarning getWarnings() throws SQLException {
    return null;
  }

  @Override
  public void clearWarnings() throws SQLException {

  }

  @Override
  public void setCursorName(String name) throws SQLException {

  }

  protected boolean isQuery(String sql){
    String _sql = sql.toLowerCase().trim();
    return _sql.startsWith("select ")
        || _sql.startsWith("show ")
        || _sql.startsWith("script ");
  }

  @Override
  public boolean execute(String sql) throws SQLException {
    if(isQuery(sql)){
      resultSet = executeQuery(sql);
    }else{
      updateCount = this.executeLargeUpdate(sql);
    }
    return true;
  }

  @Override
  public ResultSet getResultSet() throws SQLException {
    return resultSet;
  }

  @Override
  public int getUpdateCount() throws SQLException {
    return count4int(updateCount);
  }

  @Override
  public boolean getMoreResults() throws SQLException {
    return false;
  }

  @Override
  public void setFetchDirection(int direction) throws SQLException {
    this.fetchDirection = direction;
  }

  @Override
  public int getFetchDirection() throws SQLException {
    return fetchDirection;
  }

  @Override
  public void setFetchSize(int rows) throws SQLException {
    this.fetchSize = rows;
  }

  @Override
  public int getFetchSize() throws SQLException {
    return fetchSize;
  }

  @Override
  public int getResultSetConcurrency() throws SQLException {
    return 0;
  }

  @Override
  public int getResultSetType() throws SQLException {
    return 0;
  }

  @Override
  public void addBatch(String sql) throws SQLException {
    this.batchCommands.add(sql);
  }

  @Override
  public void clearBatch() throws SQLException {
    this.batchCommands.clear();
  }

  @Override
  public int[] executeBatch() throws SQLException {
    long[] counts = executeLargeBatch();
    int[] updateCounts = new int[counts.length];
    for (int i = 0; i < counts.length; i++) {
      updateCounts[i] = count4int(counts[i]);
    }
    return updateCounts;
  }

  @Override
  public Connection getConnection() throws SQLException {
    checkClose();
    return sqlClient.getConnection();
  }

  protected void checkClose() throws SQLException {
    if(isClosed()){
      throw new SQLException("connection is closed.");
    }
  }

  @Override
  public boolean getMoreResults(int current) throws SQLException {
    return false;
  }

  @Override
  public ResultSet getGeneratedKeys() throws SQLException {
    return null;
  }

  @Override
  public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
    long updateCount = executeLargeUpdate(sql, autoGeneratedKeys);
    return count4int(updateCount);
  }

  @Override
  public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
    long updateCount = executeLargeUpdate(sql, columnIndexes);
    return count4int(updateCount);
  }

  @Override
  public int executeUpdate(String sql, String[] columnNames) throws SQLException {
    long updateCount = executeLargeUpdate(sql, columnNames);
    return count4int(updateCount);
  }

  @Override
  public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
    return false;
  }

  @Override
  public boolean execute(String sql, int[] columnIndexes) throws SQLException {
    return false;
  }

  @Override
  public boolean execute(String sql, String[] columnNames) throws SQLException {
    return false;
  }

  @Override
  public int getResultSetHoldability() throws SQLException {
    return 0;
  }

  @Override
  public boolean isClosed() throws SQLException {
    return sqlClient==null;
  }

  @Override
  public void setPoolable(boolean poolable) throws SQLException {

  }

  @Override
  public boolean isPoolable() throws SQLException {
    return true;
  }

  @Override
  public void closeOnCompletion() throws SQLException {

  }

  @Override
  public boolean isCloseOnCompletion() throws SQLException {
    return false;
  }


  @Override
  public <T> T unwrap(Class<T> iface) throws SQLException {
    try {
      if (isWrapperFor(iface)) {
        return (T) this;
      }
      throw DbException.getInvalidValueException("iface", iface);
    } catch (Exception e) {
      throw new SQLException(e);
    }
  }

  @Override
  public boolean isWrapperFor(Class<?> iface) throws SQLException {
    return iface != null && iface.isAssignableFrom(getClass());
  }

  protected SQLException unsupported(String message) {
    throw DbException.getUnsupportedException(message);
  }
}
