package net.xdob.ratly.jdbc.sql;

import net.xdob.ratly.jdbc.*;
import net.xdob.ratly.proto.jdbc.*;
import net.xdob.ratly.protocol.Message;
import net.xdob.ratly.protocol.RaftClientReply;
import net.xdob.ratly.protocol.SerialSupport;
import org.h2.message.DbException;

import java.io.IOException;
import java.sql.*;
import java.util.ArrayList;

public class JdbcStatement implements Statement {
  private final ArrayList<String> batchCommands = new ArrayList<>();

  protected SqlClient sqlClient;
  protected ResultSet resultSet;
  protected long updateCount;
  private int fetchDirection;
  private int fetchSize;

  public JdbcStatement(SqlClient sqlClient) {
    this.sqlClient = sqlClient;
  }



  @Override
  public ResultSet executeQuery(String sql) throws SQLException {
    QueryRequest queryRequest = newQueryRequest()
        .setSql(sql);
    return sendQuery(queryRequest);
  }

  protected QueryRequest newQueryRequest() {
    return new QueryRequest()
        .setDb(sqlClient.getCi().getDb())
        .setSender(Sender.statement)
        .setSession(sqlClient.getConnection().getSession())
        //.setTx(sqlClient.getTx())
        .setType(QueryType.query)
        .setFetchDirection(fetchDirection)
        .setFetchSize(fetchSize);
  }

  protected SerialResultSet sendQuery(QueryRequest queryRequest) throws SQLException {
    QueryReply queryReply = sendQueryRequest(queryRequest);
    if(queryReply.getEx()==null) {
      SerialResultSet rs = (SerialResultSet) queryReply.getRs();
      rs.resetResult();
      return rs;
    }else{
      throw queryReply.getEx();
    }
  }

  protected QueryReply sendQueryRequest(QueryRequest queryRequest) throws SQLException {
    try {
      WrapRequestProto msgProto = WrapRequestProto.newBuilder()
          .setType(DBSMPlugin.DB)
          .setMsg(sqlClient.getFasts().asByteString(queryRequest))
          .build();
      RaftClientReply reply =
          sqlClient.getClient().io().sendReadOnly(Message.valueOf(msgProto));
      WrapReplyProto replyProto = WrapReplyProto.parseFrom(reply.getMessage().getContent());
      if(!replyProto.getEx().isEmpty()){
        throw (SQLException) sqlClient.getFasts().as(replyProto.getEx());
      }
      return sqlClient.getFasts().as(replyProto.getRelay());
    } catch (IOException e) {
      throw new SQLException(e);
    }
  }

  protected SerialSupport getFasts() {
    return sqlClient.getFasts();
  }


  @Override
  public long getLargeUpdateCount() throws SQLException {
    return updateCount;
  }

  @Override
  public void setLargeMaxRows(long max) throws SQLException {
    Statement.super.setLargeMaxRows(max);
  }

  @Override
  public long getLargeMaxRows() throws SQLException {
    return Statement.super.getLargeMaxRows();
  }

  @Override
  public long[] executeLargeBatch() throws SQLException {
    UpdateRequest updateRequest = newUpdateRequest();
    for (int i = 0; i < batchCommands.size(); i++) {
      updateRequest.getBatchSql().add(batchCommands.get(i));
    }
    return sendUpdateBatch(updateRequest);
  }


  protected UpdateRequest newUpdateRequest() {
    return new UpdateRequest()
        .setDb(sqlClient.getCi().getDb())
        .setSender(Sender.statement)
        .setSession(sqlClient.getConnection().getSession())
        .setTx(sqlClient.getTx())
        .setType(UpdateType.execute);
  }

  @Override
  public long executeLargeUpdate(String sql) throws SQLException {
    UpdateRequest updateRequest = newUpdateRequest()
        .setSql(sql);
    return sendUpdate(updateRequest);
  }

  @Override
  public long executeLargeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
    UpdateRequest updateRequest = newUpdateRequest()
        .setSql(sql);
    return sendUpdate(updateRequest);
  }

  @Override
  public long executeLargeUpdate(String sql, int[] columnIndexes) throws SQLException {
    UpdateRequest updateRequest = newUpdateRequest()
        .setSql(sql);
    return sendUpdate(updateRequest);
  }

  @Override
  public long executeLargeUpdate(String sql, String[] columnNames) throws SQLException {
    UpdateRequest updateRequest = newUpdateRequest()
        .setSql(sql);
    return sendUpdate(updateRequest);
  }

  @Override
  public int executeUpdate(String sql) throws SQLException {
    long updateCount = executeLargeUpdate(sql);
    return count4int(updateCount);
  }

  protected int count4int(long updateCount) {
    return updateCount <= 2147483647L ? (int) updateCount : -2;
  }

  protected long sendUpdate(UpdateRequest updateRequest) throws SQLException {
    checkClose();
    try {
      WrapRequestProto msgProto = WrapRequestProto.newBuilder()
          .setType(DBSMPlugin.DB)
          .setMsg(sqlClient.getFasts().asByteString(updateRequest))
          .build();
      RaftClientReply reply =
          sqlClient.getClient().io().send(Message.valueOf(msgProto));
      WrapReplyProto replyProto = WrapReplyProto.parseFrom(reply.getMessage().getContent());
      if(!replyProto.getEx().isEmpty()){
        throw (SQLException) sqlClient.getFasts().as(replyProto.getEx());
      }
      UpdateReply updateReply = sqlClient.getFasts().as(replyProto.getRelay());
      if(updateReply.getEx()==null) {
        sqlClient.addAndGetUpdateCount(1);
        return updateReply.getCount();
      }else{
        throw updateReply.getEx();
      }
    } catch (IOException e) {
      throw new SQLException(e);
    }
  }

  protected long[] sendUpdateBatch(UpdateRequest updateRequest) throws SQLException {
    checkClose();
    try {
      WrapRequestProto msgProto = WrapRequestProto.newBuilder()
          .setType(DBSMPlugin.DB)
          .setMsg(sqlClient.getFasts().asByteString(updateRequest))
          .build();
      RaftClientReply reply =
          sqlClient.getClient().io().send(Message.valueOf(msgProto));
      WrapReplyProto replyProto = WrapReplyProto.parseFrom(reply.getMessage().getContent());
      if(!replyProto.getEx().isEmpty()){
        throw (SQLException) sqlClient.getFasts().as(replyProto.getEx());
      }
      UpdateReply updateReply = sqlClient.getFasts().as(replyProto.getRelay());
      if(updateReply.getEx()==null) {
        if(!updateRequest.getBatchSql().isEmpty()) {
          sqlClient.addAndGetUpdateCount(updateRequest.getBatchSql().size());
        }
        if(!updateRequest.getBatchParams().isEmpty()) {
          sqlClient.addAndGetUpdateCount(updateRequest.getBatchParams().size());
        }
        long[] updateCounts = new long[updateReply.getCounts().size()];
        for (int i = 0; i < updateReply.getCounts().size(); i++) {
          updateCounts[i] = updateReply.getCounts().get(i);
        }
        return updateCounts;
      }else{
        throw updateReply.getEx();
      }
    } catch (IOException e) {
      throw new SQLException(e);
    }
  }

  @Override
  public void close() throws SQLException {
    if(sqlClient!=null) {
      sqlClient.close();
      sqlClient = null;
    }
  }

  @Override
  public int getMaxFieldSize() throws SQLException {
    return 0;
  }

  @Override
  public void setMaxFieldSize(int max) throws SQLException {

  }

  @Override
  public int getMaxRows() throws SQLException {
    return 0;
  }

  @Override
  public void setMaxRows(int max) throws SQLException {

  }

  @Override
  public void setEscapeProcessing(boolean enable) throws SQLException {

  }

  @Override
  public int getQueryTimeout() throws SQLException {
    return 0;
  }

  @Override
  public void setQueryTimeout(int seconds) throws SQLException {

  }

  @Override
  public void cancel() throws SQLException {
  }

  @Override
  public SQLWarning getWarnings() throws SQLException {
    return null;
  }

  @Override
  public void clearWarnings() throws SQLException {

  }

  @Override
  public void setCursorName(String name) throws SQLException {

  }

  protected boolean isQuery(String sql){
    String _sql = sql.toLowerCase().trim();
    return _sql.startsWith("select ")
        || _sql.startsWith("show ")
        || _sql.startsWith("script ");
  }

  @Override
  public boolean execute(String sql) throws SQLException {
    if(isQuery(sql)){
      resultSet = executeQuery(sql);
    }else{
      updateCount = this.executeLargeUpdate(sql);
    }
    return true;
  }

  @Override
  public ResultSet getResultSet() throws SQLException {
    return resultSet;
  }

  @Override
  public int getUpdateCount() throws SQLException {
    return count4int(updateCount);
  }

  @Override
  public boolean getMoreResults() throws SQLException {
    return false;
  }

  @Override
  public void setFetchDirection(int direction) throws SQLException {
    this.fetchDirection = direction;
  }

  @Override
  public int getFetchDirection() throws SQLException {
    return fetchDirection;
  }

  @Override
  public void setFetchSize(int rows) throws SQLException {
    this.fetchSize = rows;
  }

  @Override
  public int getFetchSize() throws SQLException {
    return fetchSize;
  }

  @Override
  public int getResultSetConcurrency() throws SQLException {
    return 0;
  }

  @Override
  public int getResultSetType() throws SQLException {
    return 0;
  }

  @Override
  public void addBatch(String sql) throws SQLException {
    this.batchCommands.add(sql);
  }

  @Override
  public void clearBatch() throws SQLException {
    this.batchCommands.clear();
  }

  @Override
  public int[] executeBatch() throws SQLException {
    long[] counts = executeLargeBatch();
    int[] updateCounts = new int[counts.length];
    for (int i = 0; i < counts.length; i++) {
      updateCounts[i] = count4int(counts[i]);
    }
    return updateCounts;
  }

  @Override
  public Connection getConnection() throws SQLException {
    checkClose();
    return sqlClient.getConnection();
  }

  protected void checkClose() throws SQLException {
    if(isClosed()){
      throw new SQLException("connection is closed.");
    }
  }

  @Override
  public boolean getMoreResults(int current) throws SQLException {
    return false;
  }

  @Override
  public ResultSet getGeneratedKeys() throws SQLException {
    return null;
  }

  @Override
  public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
    long updateCount = executeLargeUpdate(sql, autoGeneratedKeys);
    return count4int(updateCount);
  }

  @Override
  public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
    long updateCount = executeLargeUpdate(sql, columnIndexes);
    return count4int(updateCount);
  }

  @Override
  public int executeUpdate(String sql, String[] columnNames) throws SQLException {
    long updateCount = executeLargeUpdate(sql, columnNames);
    return count4int(updateCount);
  }

  @Override
  public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
    return false;
  }

  @Override
  public boolean execute(String sql, int[] columnIndexes) throws SQLException {
    return false;
  }

  @Override
  public boolean execute(String sql, String[] columnNames) throws SQLException {
    return false;
  }

  @Override
  public int getResultSetHoldability() throws SQLException {
    return 0;
  }

  @Override
  public boolean isClosed() throws SQLException {
    return sqlClient==null;
  }

  @Override
  public void setPoolable(boolean poolable) throws SQLException {

  }

  @Override
  public boolean isPoolable() throws SQLException {
    return true;
  }

  @Override
  public void closeOnCompletion() throws SQLException {

  }

  @Override
  public boolean isCloseOnCompletion() throws SQLException {
    return false;
  }


  @Override
  public <T> T unwrap(Class<T> iface) throws SQLException {
    try {
      if (isWrapperFor(iface)) {
        return (T) this;
      }
      throw DbException.getInvalidValueException("iface", iface);
    } catch (Exception e) {
      throw new SQLException(e);
    }
  }

  @Override
  public boolean isWrapperFor(Class<?> iface) throws SQLException {
    return iface != null && iface.isAssignableFrom(getClass());
  }

  protected SQLException unsupported(String message) {
    throw DbException.getUnsupportedException(message);
  }
}
