package net.xdob.jdbc.sql;

import net.sf.jsqlparser.JSQLParserException;
import net.xdob.jdbc.util.CustomSqlParser;
import net.xdob.jdbc.util.JSqlParserWithLRUCache;
import net.xdob.jdbc.util.SQLStatementUtil;
import net.xdob.ratly.proto.jdbc.*;
import net.xdob.ratly.proto.sm.WrapReplyProto;
import net.xdob.ratly.proto.sm.WrapRequestProto;
import net.xdob.ratly.protocol.Message;
import net.xdob.ratly.protocol.RaftClientReply;
import net.xdob.ratly.util.Proto2Util;
import org.h2.message.DbException;

import java.io.IOException;
import java.lang.reflect.Proxy;
import java.sql.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class JdbcStatement implements Statement {
  private final List<String> batchCommands = Collections.synchronizedList(new ArrayList<>());

  protected SqlClient sqlClient;
  protected ResultSet resultSet;
  protected long updateCount;
  private int fetchDirection;
  private int fetchSize;
  protected volatile int limit = 100;


  public JdbcStatement(SqlClient sqlClient) {
    this.sqlClient = sqlClient;
  }



  @Override
  public ResultSet executeQuery(String sql) throws SQLException {
    SqlRequestProto.Builder sqlBuilder = newSqlRequestBuilder(SqlRequestType.query);
 		sqlBuilder.setSql( sql);
    return sendQuery(sqlBuilder);
  }


  protected ResultSet sendQuery(SqlRequestProto.Builder sqlBuilder) throws SQLException {
		sqlBuilder.setVersion(1);
		JdbcRequestProto requestProto = newRequestBuilder()
        .setSqlRequest(sqlBuilder)
        .build();
    JdbcResponseProto responseProto = sendReadOnly(requestProto);
		if(responseProto.hasRemoteResultSet2()){
			RemoteResultSet2Proto remoteResultSet = responseProto.getRemoteResultSet2();

			return new RemoteResultSet(sqlBuilder, this.sqlClient, remoteResultSet);
		}else {
			return SerialResultSet.from(responseProto.getResultSet());
		}
  }



  @Override
  public long getLargeUpdateCount() throws SQLException {
    return updateCount;
  }

  @Override
  public void setLargeMaxRows(long max) throws SQLException {
    Statement.super.setLargeMaxRows(max);
  }

  @Override
  public long getLargeMaxRows() throws SQLException {
    return Statement.super.getLargeMaxRows();
  }

  @Override
  public long[] executeLargeBatch() throws SQLException {
    List<Long> batchCounts = new ArrayList<>();

    int start = 0;
    SqlRequestProto.Builder sqlBuilder = newSqlRequestBuilder(SqlRequestType.update);
    while (start < batchCommands.size()) {
      sqlBuilder.clearBatchSql();
      batchCommands.stream()
          .skip(start)
          .limit(limit)
          .forEach(sqlBuilder::addBatchSql);
      start += sqlBuilder.getBatchSqlCount();
      long[] counts = sendUpdateBatch(sqlBuilder);
      for (long count : counts) {
        batchCounts.add(count);
      }
    }
    return batchCounts.stream()
        .mapToLong(Long::longValue)
        .toArray() ;
  }



  @Override
  public long executeLargeUpdate(String sql) throws SQLException {
    SqlRequestProto.Builder sqlBuilder = newSqlRequestBuilder(SqlRequestType.update);
    sqlBuilder.setSql(sql);
    return sendUpdate(sqlBuilder);
  }

  @Override
  public long executeLargeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
    SqlRequestProto.Builder sqlBuilder = newSqlRequestBuilder(SqlRequestType.update);
    sqlBuilder.setSql(sql);
    return sendUpdate(sqlBuilder);
  }

  @Override
  public long executeLargeUpdate(String sql, int[] columnIndexes) throws SQLException {
    SqlRequestProto.Builder sqlBuilder = newSqlRequestBuilder(SqlRequestType.update);
    sqlBuilder.setSql(sql);
    return sendUpdate(sqlBuilder);
  }

  @Override
  public long executeLargeUpdate(String sql, String[] columnNames) throws SQLException {
    SqlRequestProto.Builder sqlBuilder = newSqlRequestBuilder(SqlRequestType.update);
    sqlBuilder.setSql(sql);
    return sendUpdate(sqlBuilder);
  }

  @Override
  public int executeUpdate(String sql) throws SQLException {
    long updateCount = executeLargeUpdate(sql);
    return count4int(updateCount);
  }

  protected int count4int(long updateCount) {
    return updateCount <= 2147483647L ? (int) updateCount : -2;
  }

  protected long sendUpdate(SqlRequestProto.Builder sqlBuilder) throws SQLException {
    checkClose();
    JdbcRequestProto requestProto = newRequestBuilder()
        .setSqlRequest(sqlBuilder)
        .build();
    JdbcResponseProto responseProto = send(requestProto);
    return responseProto.getUpdateCount();
  }

  protected long[] sendUpdateBatch(SqlRequestProto.Builder sqlBuilder) throws SQLException {
    checkClose();
    JdbcRequestProto requestProto = newRequestBuilder()
        .setSqlRequest(sqlBuilder)
        .build();
    JdbcResponseProto responseProto = send(requestProto);
    return responseProto.getUpdateCounts().getUpdateCountList()
        .stream().mapToLong(Long::longValue)
        .toArray();
  }



  protected JdbcRequestProto.Builder newRequestBuilder() {
		return JdbcRequestProto.newBuilder()
				.setDb(sqlClient.ci.getDb())
				.setSessionId(sqlClient.getConnection().getSession());
  }

  protected  SqlRequestProto.Builder newSqlRequestBuilder(SqlRequestType type) {
		return SqlRequestProto.newBuilder()
				.setStmtType(StmtType.statement)
				.setType(type);
  }

  protected JdbcResponseProto send(JdbcRequestProto request) throws SQLException {
    sqlClient.getConnection().checkClose();
		try {
      WrapRequestProto wrap = WrapRequestProto.newBuilder()
          .setType(JdbcConnection.DB)
          .setJdbcRequest(request)
          .build();
      RaftClientReply reply =
          sqlClient.getClient().io().send(Message.valueOf(wrap));
      WrapReplyProto replyProto = WrapReplyProto.parseFrom(reply.getMessage().getContent());
      JdbcResponseProto response = replyProto.getJdbcResponse();
      if(response.hasEx()){
        throw Proto2Util.toSQLException(response.getEx());
      }
      return response;
    } catch (IOException e) {
      throw new SQLException(e);
    }
  }

  protected JdbcResponseProto sendReadOnly(JdbcRequestProto request) throws SQLException {
		sqlClient.getConnection().checkClose();
		try {
      WrapRequestProto wrap = WrapRequestProto.newBuilder()
          .setType(JdbcConnection.DB)
          .setJdbcRequest(request)
          .build();
      RaftClientReply reply =
          sqlClient.getClient().io().sendReadOnly(Message.valueOf(wrap));

      WrapReplyProto replyProto = WrapReplyProto.parseFrom(reply.getMessage().getContent());
      JdbcResponseProto response = replyProto.getJdbcResponse();
      if(response.hasEx()){
        throw Proto2Util.toSQLException(response.getEx());
      }
      return response;
    } catch (IOException e) {
      throw new SQLException(e);
    }
  }

  @Override
  public void close() throws SQLException {
    if(sqlClient!=null) {
      sqlClient.close();
      sqlClient = null;
    }
  }

  @Override
  public int getMaxFieldSize() throws SQLException {
    return 0;
  }

  @Override
  public void setMaxFieldSize(int max) throws SQLException {

  }

  @Override
  public int getMaxRows() throws SQLException {
    return 0;
  }

  @Override
  public void setMaxRows(int max) throws SQLException {

  }

  @Override
  public void setEscapeProcessing(boolean enable) throws SQLException {

  }

  @Override
  public int getQueryTimeout() throws SQLException {
    return 0;
  }

  @Override
  public void setQueryTimeout(int seconds) throws SQLException {

  }

  @Override
  public void cancel() throws SQLException {
  }

  @Override
  public SQLWarning getWarnings() throws SQLException {
    return null;
  }

  @Override
  public void clearWarnings() throws SQLException {

  }

  @Override
  public void setCursorName(String name) throws SQLException {

  }

  protected boolean isModification(String sql) throws SQLException {
		try{
			net.sf.jsqlparser.statement.Statement statement = JSqlParserWithLRUCache.parse(sql);
			return SQLStatementUtil.isModification(statement);
		}catch (JSQLParserException e) {
			throw new SQLException("sql parse error. sql="+sql, e);
		}
  }

  @Override
  public boolean execute(String sql) throws SQLException {
		if(!isModification(sql)){
			resultSet = executeQuery(sql);
			return true;
		}else{
			updateCount = this.executeLargeUpdate(sql);
			return false;
		}
  }

  @Override
  public ResultSet getResultSet() throws SQLException {
    return resultSet;
  }

  @Override
  public int getUpdateCount() throws SQLException {
    return count4int(updateCount);
  }

  @Override
  public boolean getMoreResults() throws SQLException {
    return false;
  }

  @Override
  public void setFetchDirection(int direction) throws SQLException {
    this.fetchDirection = direction;
  }

  @Override
  public int getFetchDirection() throws SQLException {
    return fetchDirection;
  }

  @Override
  public void setFetchSize(int rows) throws SQLException {
    this.fetchSize = rows;
  }

  @Override
  public int getFetchSize() throws SQLException {
    return fetchSize;
  }

  @Override
  public int getResultSetConcurrency() throws SQLException {
    return 0;
  }

  @Override
  public int getResultSetType() throws SQLException {
    return 0;
  }

  @Override
  public void addBatch(String sql) throws SQLException {
    this.batchCommands.add(sql);
  }

  @Override
  public void clearBatch() throws SQLException {
    this.batchCommands.clear();
  }

  @Override
  public int[] executeBatch() throws SQLException {
    long[] counts = executeLargeBatch();
    int[] updateCounts = new int[counts.length];
    for (int i = 0; i < counts.length; i++) {
      updateCounts[i] = count4int(counts[i]);
    }
    return updateCounts;
  }

  @Override
  public Connection getConnection() throws SQLException {
    checkClose();
    return sqlClient.getConnection();
  }

  protected void checkClose() throws SQLException {
    if(isClosed()){
      throw new SQLException("connection is closed.");
    }
  }

  @Override
  public boolean getMoreResults(int current) throws SQLException {
    return false;
  }

  @Override
  public ResultSet getGeneratedKeys() throws SQLException {
    return null;
  }

  @Override
  public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
    long updateCount = executeLargeUpdate(sql, autoGeneratedKeys);
    return count4int(updateCount);
  }

  @Override
  public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
    long updateCount = executeLargeUpdate(sql, columnIndexes);
    return count4int(updateCount);
  }

  @Override
  public int executeUpdate(String sql, String[] columnNames) throws SQLException {
    long updateCount = executeLargeUpdate(sql, columnNames);
    return count4int(updateCount);
  }

  @Override
  public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
    return execute(sql);
  }

  @Override
  public boolean execute(String sql, int[] columnIndexes) throws SQLException {
    return execute(sql);
  }

  @Override
  public boolean execute(String sql, String[] columnNames) throws SQLException {
    return execute(sql);
  }

  @Override
  public int getResultSetHoldability() throws SQLException {
    return 0;
  }

  @Override
  public boolean isClosed() throws SQLException {
    return sqlClient==null||sqlClient.getConnection().isClosed();
  }

  @Override
  public void setPoolable(boolean poolable) throws SQLException {

  }

  @Override
  public boolean isPoolable() throws SQLException {
    return true;
  }

  @Override
  public void closeOnCompletion() throws SQLException {

  }

  @Override
  public boolean isCloseOnCompletion() throws SQLException {
    return false;
  }


  @Override
  public <T> T unwrap(Class<T> iface) throws SQLException {
    try {
      if (isWrapperFor(iface)) {
        return (T) this;
      }
      throw DbException.getInvalidValueException("iface", iface);
    } catch (Exception e) {
      throw new SQLException(e);
    }
  }

  @Override
  public boolean isWrapperFor(Class<?> iface) throws SQLException {
    return iface != null && iface.isAssignableFrom(getClass());
  }

  protected SQLException unsupported(String message) {
    throw DbException.getUnsupportedException(message);
  }
}
